<script>
let currentUserEmail = '';
let activeDisputeEvalId = null;
let activeDisputeResolutionId = null;
let currentAuditTab = 'pending';




  document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
  attachNavHandlers();
  attachFormHandlers();
  attachAdminHandlers();
  attachDisputeHandlers();
  attachQuestionFormHandler();
});

function attachUnloadHandlerForDispute(evalId) {
  if (!evalId) return; // 🛡️ Safety check

  // Clear any previous handler
  if (window.handleDisputeUnloadUnlock) {
    window.removeEventListener('beforeunload', window.handleDisputeUnloadUnlock);
  }

  // Define and attach new handler
  window.handleDisputeUnloadUnlock = function() {
    google.script.run.resetEvalStatusFromReviewing(evalId);
  };

  window.addEventListener('beforeunload', window.handleDisputeUnloadUnlock);
}

function removeUnloadHandlerForDispute() {
  if (window.handleDisputeUnloadUnlock) {
    window.removeEventListener('beforeunload', window.handleDisputeUnloadUnlock);
    delete window.handleDisputeUnloadUnlock;
  }

  if (activeDisputeEvalId) {
    google.script.run.resetEvalStatusFromReviewing(activeDisputeEvalId);
    activeDisputeEvalId = null;
  }
}

function attachUnloadHandlerForDisputeResolution(disputeId) {
  if (!disputeId) return;

  window.originalDisputeStatus = window.originalDisputeStatus || 'pending'; // fallback
  activeDisputeResolutionId = disputeId;

  // Remove any existing handler first
  if (window.handleDisputeResolutionUnload) {
    window.removeEventListener('beforeunload', window.handleDisputeResolutionUnload);
  }

  window.handleDisputeResolutionUnload = function () {
    // Reset only if still "reviewing"
    google.script.run
      .withFailureHandler(err => console.warn('Unload reset failed:', err))
      .updateDisputeStatus(disputeId, window.originalDisputeStatus || 'pending');
  };

  window.addEventListener('beforeunload', window.handleDisputeResolutionUnload);
}

function removeUnloadHandlerForDisputeResolution() {
  if (window.handleDisputeResolutionUnload) {
    window.removeEventListener('beforeunload', window.handleDisputeResolutionUnload);
    delete window.handleDisputeResolutionUnload;
  }

    if (activeDisputeResolutionId) {
    const idToReset = activeDisputeResolutionId;
    const statusToRestore = window.originalDisputeStatus || 'pending';
  
    google.script.run
      .withSuccessHandler(serverStatus => {
        const current = (serverStatus || '').toLowerCase();
        if (current === 'reviewing') {
          google.script.run
            .withFailureHandler(err => console.warn('Reset failed:', err))
            .updateDisputeStatus(idToReset, statusToRestore);
        }
      })
      .withFailureHandler(err => console.warn('Status check failed:', err))
      .checkDisputeReviewStatus(idToReset);
  
    activeDisputeResolutionId = null;
    delete window.originalDisputeStatus;
  }
}

  function showToast(message, type = 'info') {
    const container = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = 'toast';

    if (type === 'success') toast.style.backgroundColor = '#28a745';
    else if (type === 'error') toast.style.backgroundColor = '#dc3545';
    else if (type === 'warning') toast.style.backgroundColor = '#ffc107';

    toast.textContent = message;
    container.appendChild(toast);

    setTimeout(() => toast.remove(), 3000);
  };

  function initializeApp() {
    google.script.run.withSuccessHandler(user => {
      currentUserEmail = user.email; // ✅ Save current user
      document.getElementById('userName').textContent = user.name;
      document.getElementById('userRole').textContent = formatRole(user.role);
      document.getElementById('evaluationForm')?.removeAttribute('data-audit-id');

      const isAdmin = user.role === 'admin' || user.role === 'qa_manager';
      document.getElementById('navAdmin').style.display = isAdmin ? 'block' : 'none';

      if (user.role === 'qa_analyst' || user.role === 'qa_manager') {
        showAuditQueue();
      } else {
        showDashboard();
      }
    }).getCurrentUser();
  }

  function formatRole(role) {
    return role
      ? role.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')
      : 'Unknown';
  }

  function attachNavHandlers() {
  const nav = [
    ['navDashboard', showDashboard],
    ['navAuditQueue', showAuditQueue],
    ['navEvaluations', showEvaluations],
    ['navDisputes', showDisputes],
    ['navAdmin', showAdmin]
  ];

  nav.forEach(([id, handler]) => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('click', handler);
  });
}

function attachAuditTabHandlers() {
  const tabPending = document.getElementById('tabPendingAudits');
  const tabError = document.getElementById('tabErrorAudits');

  if (!tabPending || !tabError) return;

  tabPending.addEventListener('click', () => {
    if (currentAuditTab === 'pending') return;

    currentAuditTab = 'pending';
    tabPending.classList.add('active');
    tabError.classList.remove('active');

    loadPendingTasks();
  });

  tabError.addEventListener('click', () => {
    if (currentAuditTab === 'error') return;

    currentAuditTab = 'error';
    tabError.classList.add('active');
    tabPending.classList.remove('active');

    loadErrorTasks();
  });
}

  function attachDisputeHandlers() {
    const form = document.getElementById('resolveDisputeForm');
    if (!form) return;

  form.addEventListener('submit', handleResolveDisputeSubmit);
}

function attachQuestionFormHandler() {
  const form = document.getElementById('questionForm');
  if (!form) return;

  // Prevent multiple bindings
  form.removeEventListener('submit', handleQuestionFormSubmit);
  form.addEventListener('submit', handleQuestionFormSubmit);

  // Cancel button logic
  document.getElementById('cancelQuestion')?.addEventListener('click', () => {
    form.reset();
    document.getElementById('questionFormView').classList.add('hidden');
  });
}


  function showDashboard() {
    hideAllViews();
    document.getElementById('dashboardView')?.classList.remove('hidden');
    highlightNavItem('navDashboard');
    document.getElementById('dashboardStatsCard')?.classList.remove('hidden');
    document.getElementById('importAuditCard')?.classList.remove('hidden');
    loadDashboardStats();
  }

  function handleDashboardNav(targetFn) {
    document.getElementById('dashboardStatsCard')?.classList.add('hidden');
    document.getElementById('importAuditCard')?.classList.add('hidden');
    targetFn();
  }

   function loadDashboardStats() {
    // Step 1: Get pending audits
    google.script.run.withSuccessHandler(function(audits) {
      const total = audits.length;
      document.getElementById('pendingAuditsCount').textContent = total;

      // Step 2: Get completed evaluations
      google.script.run.withSuccessHandler(function(evaluations) {
        const completed = evaluations.filter(e => e.status === 'completed').length;
        document.getElementById('completedEvalsCount').textContent = completed;

        // Step 3: Calculate completion %
        const percentage = total === 0 ? 0 : Math.round((completed / total) * 100);

        const bar = document.getElementById('evalProgressBar');
        const text = document.getElementById('evalProgressText');

        // Determine progress bar color class
        let progressClass = 'progress-green';
        if (percentage < 70) progressClass = 'progress-red';
        else if (percentage < 90) progressClass = 'progress-yellow';

        // Update bar and text
        bar.style.width = percentage + '%';
        bar.className = `progress-bar-fill ${progressClass}`;
        text.textContent = percentage + '%';

      }).getAllEvaluations();
    }).getPendingAudits();

    // Step 4: Load dispute stats
    google.script.run.withSuccessHandler(function(stats) {
      document.getElementById('disputedEvalsCount').textContent = stats.total;
      document.getElementById('partialOverturns').textContent = stats.partialOverturns;
      document.getElementById('totalOverturned').textContent = stats.totalOverturned;
      document.getElementById('disputesUpheld').textContent = stats.disputesUpheld;
    }).getDisputeStats();
  }

  // == Form + Button Event Handlers ==
function attachFormHandlers() {
  // -------------------------
  // Evaluation Cancel Handler
  // -------------------------
  const cancelEval = document.getElementById('cancelEvaluation');
  const evalForm = document.getElementById('evaluationForm');

  if (cancelEval) {
    cancelEval.addEventListener('click', () => {
      const form = document.getElementById('evaluationForm');
      const auditId = form.getAttribute('data-audit-id');

      if (auditId) {
        google.script.run.updateAuditStatusAndLock(auditId, 'pending');
      }

      // Cleanup: heartbeat + unload listener
      clearInterval(window.auditHeartbeat);
      window.removeEventListener('beforeunload', window.boundUnloadUnlockHandler);
      delete window.boundUnloadUnlockHandler;

      resetEvaluationForm();
      showAuditQueue();
    });
  }

  if (evalForm) evalForm.addEventListener('submit', handleEvaluationSubmit);

  // -------------------------
  // Dispute Cancel Handler
  // -------------------------
  const cancelDispute = document.getElementById('cancelDispute');
  const disputeForm = document.getElementById('disputeForm');

  if (cancelDispute) {
    cancelDispute.addEventListener('click', () => {
      const form = document.getElementById('disputeForm');
      const evalId = form.getAttribute('data-evaluation-id');

  if (evalId) {
    attachUnloadHandlerForDispute(evalId);
  }

      // Cleanup: unload listener
      window.removeEventListener('beforeunload', window.handleDisputeUnloadUnlock);
      delete window.handleDisputeUnloadUnlock;

      showEvaluations();
    });
  }

  if (disputeForm) {
    disputeForm.addEventListener('submit', handleDisputeSubmit);

    // Add unload listener for status reset
    const evalId = disputeForm.getAttribute('data-evaluation-id');
    if (evalId) {
      // Prevent multiple listeners
      if (window.handleDisputeUnloadUnlock) {
        window.removeEventListener('beforeunload', window.handleDisputeUnloadUnlock);
      }

      window.handleDisputeUnloadUnlock = () => {
        google.script.run.resetEvalStatusFromReviewing(evalId);
      };
      window.addEventListener('beforeunload', window.handleDisputeUnloadUnlock);
    }
  }

  // -------------------------
  // Import Button Handler
  // -------------------------
  const importBtn = document.getElementById('importButton');
  if (importBtn) {
    importBtn.addEventListener('click', () => {
      const statusDiv = document.getElementById('importStatus');
      if (!statusDiv) return;

      statusDiv.innerHTML = '<div class="alert alert-info">Importing data from email... This may take a moment.</div>';

      google.script.run
        .withSuccessHandler(result => {
          statusDiv.innerHTML = result.success
            ? `<div class="alert alert-success">${result.message}</div>`
            : `<div class="alert alert-danger">${result.message}</div>`;
          if (result.success) loadDashboardStats();
        })
        .withFailureHandler(error => {
          statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
        })
        .importDataFromEmail();
    });
  }
}

 function attachAdminHandlers() {
  const userBtn = document.getElementById('adminUsers');
  const qBtn = document.getElementById('adminQuestions');
  const setBtn = document.getElementById('adminSettings');

  if (userBtn) {
    userBtn.addEventListener('click', () => {
      showAdminTab('adminUsersView');
      loadUsers();
      hideUserForm();
    });
  }

  if (qBtn) {
    qBtn.addEventListener('click', () => {
      showAdminTab('adminQuestionsView');
      loadQuestions();
    });
  }

  if (setBtn) {
    setBtn.addEventListener('click', () => {
      showAdminTab('adminSettingsView');
    });
  }

  const addUserBtn = document.getElementById('addUserBtn');
  if (addUserBtn) addUserBtn.addEventListener('click', showAddUserForm);

  const cancelUser = document.getElementById('cancelUserForm');
  if (cancelUser) cancelUser.addEventListener('click', hideUserForm);

  const userForm = document.getElementById('userFormElement');
  if (userForm) userForm.addEventListener('submit', handleUserFormSubmit);

  const addQ = document.getElementById('addQuestionBtn');
  const cancelQ = document.getElementById('cancelQuestionForm');
  const qForm = document.getElementById('questionFormElement');
  const filter = document.getElementById('taskTypeFilter');

  if (addQ) addQ.addEventListener('click', showAddQuestionForm);
  if (cancelQ) cancelQ.addEventListener('click', hideQuestionForm);
  if (qForm) qForm.addEventListener('submit', handleQuestionFormSubmit);
  if (filter) filter.addEventListener('change', loadQuestions);
}

  // Show the Add User form with cleared values
function showAddUserForm() {
  showUserForm();  // This calls the already defined generic showUserForm()
}

// Show the Add Question form with cleared values
function showAddQuestionForm() {
  showQuestionForm(); // This calls the already defined generic showQuestionForm()
}

  function highlightNavItem(navId) {
    document.querySelectorAll('nav button').forEach(btn => btn.classList.remove('active'));
    document.getElementById(navId)?.classList.add('active');
  }

  function showDashboard() {
    clearAuditLockIfExists(); // ✅ ensures stale lock is cleared
    removeUnloadHandlerForDispute(); // ✅ Redundant safeguard
    hideAllViews();
    document.getElementById('dashboardView')?.classList.remove('hidden');
    highlightNavItem('navDashboard');
    loadDashboardStats();
    document.getElementById('dashboardStatsCard')?.classList.remove('hidden');
    document.getElementById('importAuditCard')?.classList.remove('hidden');
  }

  function handleDashboardNav(targetFn) {
    document.getElementById('dashboardStatsCard')?.classList.add('hidden');
    document.getElementById('importAuditCard')?.classList.add('hidden');
    targetFn();
  }

  function showEvaluations() {
    clearAuditLockIfExists(); // ✅ ensures stale lock is cleared
    removeUnloadHandlerForDispute(); // ✅ Redundant safeguard
    hideAllViews();
    document.getElementById('evaluationsView')?.classList.remove('hidden');
    highlightNavItem('navEvaluations');
    loadEvaluations();
  }

  function showDisputes() {
    clearAuditLockIfExists(); // ✅ ensures stale lock is cleared
    removeUnloadHandlerForDispute(); // ✅ Redundant safeguard
    hideAllViews();
    document.getElementById('disputesView')?.classList.remove('hidden');
    highlightNavItem('navDisputes');
    loadDisputes();
  }

  function showAdmin() {
    clearAuditLockIfExists(); // ✅ ensures stale lock is cleared
    removeUnloadHandlerForDispute(); // ✅ Redundant safeguard
    hideAllViews();
    document.getElementById('adminView')?.classList.remove('hidden');
    highlightNavItem('navAdmin');
    showAdminTab('adminUsersView');
    loadUsers();
    hideUserForm();
  }

function showAdminTab(tabId) {
  document.querySelectorAll('.admin-tab-content').forEach(el => el.classList.add('hidden'));
  document.getElementById(tabId)?.classList.remove('hidden');

  document.querySelectorAll('.admin-tab-item').forEach(tab => tab.classList.remove('active'));
  const tabButtonMap = {
    'adminUsersView': 'adminUsers',
    'adminQuestionsView': 'adminQuestions',
    'adminSettingsView': 'adminSettings'
  };
  const activeBtn = tabButtonMap[tabId];
  document.getElementById(activeBtn)?.classList.add('active');

  // ✅ Load dynamic dropdowns when opening the Questions tab
  if (tabId === 'adminQuestionsView') {
  loadQuestionFilters();     // ✅ Populate filters
  loadQuestionFormDropdowns();
  loadQuestions();           // ✅ Load questions list
}
}

  function loadQuestionFormDropdowns() {
  google.script.run
    .withSuccessHandler(populateRequestTypeOptions)
    .getUniqueRequestTypes();

  google.script.run
    .withSuccessHandler(populateTaskTypeOptions)
    .getUniqueTaskTypes();
}

  function loadQuestionFilters() {
  google.script.run.withSuccessHandler(types => {
    const dropdown = document.getElementById('taskTypeFilter');
    dropdown.innerHTML = '<option value="">All Types</option>';
    types.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      dropdown.appendChild(opt);
    });
  }).getUniqueTaskTypes();

  google.script.run.withSuccessHandler(types => {
    const dropdown = document.getElementById('requestTypeFilter');
    dropdown.innerHTML = '<option value="">All Requests</option>';
    types.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      dropdown.appendChild(opt);
    });
  }).getUniqueRequestTypes();
}

/*
This ensures the table refreshes whenever a filter is changed.
*/
document.getElementById('taskTypeFilter').addEventListener('change', loadQuestions);
document.getElementById('requestTypeFilter').addEventListener('change', loadQuestions);


  function populateRequestTypeOptions(types) {
  const dropdown = document.getElementById('requestTypeDropdown');
  if (!dropdown) return;

  dropdown.innerHTML = '<option value="">Select Request Type</option>';
  types.forEach(type => {
    const option = document.createElement('option');
    option.value = type;
    option.textContent = type;
    dropdown.appendChild(option);
  });
}

function populateTaskTypeOptions(types) {
  const dropdown = document.getElementById('taskTypeDropdown');
  if (!dropdown) return;

  dropdown.innerHTML = '<option value="">Select Task Type</option>';
  types.forEach(type => {
    const option = document.createElement('option');
    option.value = type;
    option.textContent = type;
    dropdown.appendChild(option);
  });
}


function showAuditQueue() {
  clearAuditLockIfExists(); // ✅ ensures stale lock is cleared
  removeUnloadHandlerForDispute(); // ✅ Redundant safeguard
  hideAllViews();
  document.getElementById('auditQueueView').classList.remove('hidden');
  highlightNavItem('navAuditQueue');

  attachAuditTabHandlers();
  loadPendingTasks();       // default tab on load
}

function loadPendingTasks() {
  currentAuditTab = 'pending'; // ✅ Track active tab
  const tableBody = document.getElementById('pendingTasksBody');
  const statusMessage = document.getElementById('auditStatusMessage');

  // ✅ Show loading spinner only in the footer, not the table
  tableBody.innerHTML = '';
  if (statusMessage) {
    statusMessage.innerHTML = `<div class="spinner-sm inline-block mr-2"></div> Loading pending audits...`;
  }

  google.script.run.withSuccessHandler(function(audits) {
    // 🛑 Cancel rendering if the tab was switched before data returned
    if (currentAuditTab !== 'pending') return;

    if (!Array.isArray(audits)) {
      console.error('Unexpected result from getPendingAudits:', audits);
      tableBody.innerHTML = '';
      if (statusMessage) statusMessage.textContent = 'Error loading audits.';
      return;
    }

    if (audits.length === 0) {
      tableBody.innerHTML = '';
      if (statusMessage) statusMessage.textContent = 'No pending audits.';
      return;
    }

    const fragment = document.createDocumentFragment();

    audits.forEach(function(audit) {
      const row = document.createElement('tr');
      const isLocked = audit.lockedBy && audit.lockedBy !== '';
      const isLockedByUser = audit.lockedBy === currentUserEmail;

      row.className = isLocked && !isLockedByUser ? 'row-locked' : '';

      row.innerHTML = `
        <td><code>${audit.auditId}</code></td>
        <td>${audit.agentEmail}</td>
        <td>${formatTaskType(audit.taskType)}</td>
        <td>${audit.referenceNumber || 'N/A'}</td>
        <td>${formatDate(audit.taskTimestamp)}</td>
        <td>
          ${isLocked
            ? `<span class="badge badge-warning" title="Locked by ${audit.lockedBy}">
                 ${isLockedByUser ? 'Locked by you' : 'Locked'}
               </span>`
            : `<span class="badge badge-pending">Pending</span>`}
        </td>
        <td>
          ${isLocked && !isLockedByUser
            ? `<button class="btn btn-sm btn-secondary" disabled title="This audit is currently being evaluated by ${audit.lockedBy}">In Use</button>`
            : `<button class="evaluate-button btn btn-sm btn-primary" data-audit-id="${audit.auditId}">
                 ${isLockedByUser ? 'Resume' : 'Evaluate'}
               </button>`}
        </td>
      `;
      fragment.appendChild(row);
    });

    tableBody.innerHTML = '';
    tableBody.appendChild(fragment);
    if (statusMessage) statusMessage.textContent = '';
  }).getPendingAudits();

  // ✅ Attach event listener once
  if (!tableBody.hasListenerAttached) {
    tableBody.addEventListener('click', function(event) {
      if (!event.target.classList.contains('evaluate-button')) return;

      const clickedButton = event.target;
      const auditId = clickedButton.getAttribute('data-audit-id');
      const originalHTML = clickedButton.innerHTML;

      const allButtons = document.querySelectorAll('.evaluate-button');
      allButtons.forEach(btn => btn.disabled = true);

      document.getElementById('evaluateModalMessage').textContent = 'Validating record availability...';
      document.getElementById('evaluateModal')?.classList.remove('hidden');

      google.script.run
        .withSuccessHandler(function(alreadyEvaluated) {
          document.getElementById('evaluateModal')?.classList.add('hidden');

          allButtons.forEach(btn => {
            btn.disabled = false;
            if (btn === clickedButton) btn.innerHTML = originalHTML;
          });

          if (alreadyEvaluated) {
            showToast("This audit has already been evaluated.", "warning");
            loadPendingTasks();
            return;
          }

          showEvaluationForm(auditId);
        })
        .withFailureHandler(function(error) {
          document.getElementById('evaluateModal')?.classList.add('hidden');
          console.error('Error checking evaluation status:', error);
          showToast("Failed to verify evaluation status. Please try again.", "error");

          allButtons.forEach(btn => {
            btn.disabled = false;
            if (btn === clickedButton) btn.innerHTML = originalHTML;
          });
        })
        .checkIfAlreadyEvaluated(auditId);
    });

    tableBody.hasListenerAttached = true;
  }
}

function showEvaluateModal() {
  document.getElementById('evaluateModal')?.classList.remove('hidden');
}

function hideEvaluateModal() {
  document.getElementById('evaluateModal')?.classList.add('hidden');
}

function loadErrorTasks() {
  const tableBody = document.getElementById('pendingTasksBody');
  const statusMessage = document.getElementById('auditStatusMessage');

  tableBody.innerHTML = '';
  if (statusMessage) statusMessage.innerHTML = `<div class="spinner-sm inline-block mr-2"></div> Loading error audits...`;

  currentAuditTab = 'error';

  google.script.run.withSuccessHandler(function(audits) {
    if (currentAuditTab !== 'error') return;

    const misconfigured = audits.filter(a => a.auditStatus === 'misconfigured');

    if (misconfigured.length === 0) {
      tableBody.innerHTML = '';
      if (statusMessage) statusMessage.textContent = 'No misconfigured audits.';
      return;
    }

    const fragment = document.createDocumentFragment();

    misconfigured.forEach(function(audit) {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td><code>${audit.auditId || 'N/A'}</code></td>
        <td>${audit.agentEmail}</td>
        <td>${formatTaskType(audit.taskType)}</td>
        <td>${audit.referenceNumber || 'N/A'}</td>
        <td>${formatDate(audit.taskTimestamp)}</td>
        <td>
          <span class="badge badge-danger" title="No questions configured for this task type">Misconfigured</span>
        </td>
        <td>
          <button class="btn btn-sm btn-secondary" disabled>Unavailable</button>
        </td>
      `;
      fragment.appendChild(row);
    });

    tableBody.innerHTML = '';
    tableBody.appendChild(fragment);
    if (statusMessage) statusMessage.textContent = '';
  }).getAllAudits();
}

  function updateAuditStatusAndLock(auditId, status) {
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler(resolve)
      .withFailureHandler(reject)
      .updateAuditStatusAndLock(auditId, status);
  });
}

function showEvaluationForm(auditId) {
  hideAllViews();
  document.getElementById('evaluationFormView').classList.remove('hidden');

  const form = document.getElementById('evaluationForm');
  const taskDetails = document.getElementById('taskDetails');
  const questionsContainer = document.getElementById('questions');
  const feedbackField = document.getElementById('feedback');

  // Clear old state
  form.reset();
  questionsContainer.innerHTML = '';
  taskDetails.innerHTML = 'Loading task details...';
  feedbackField.value = '';
  form.classList.add('disabled'); // prevent premature interaction

  ['data-audit-id', 'data-reference-number', 'data-task-type', 'data-outcome', 'data-max-score']
    .forEach(attr => form.removeAttribute(attr));

  // Fetch and render new audit
  google.script.run
    .withSuccessHandler(function(audit) {
      taskDetails.innerHTML = `
        <div class="grid-2">
          <div><p class="field-label">Agent</p><p class="field-value">${audit.agentEmail}</p></div>
          <div><p class="field-label">Task Type</p><p class="field-value">${formatTaskType(audit.taskType)}</p></div>
          <div><p class="field-label">Reference Number</p><p class="field-value">${audit.referenceNumber || 'N/A'}</p></div>
          <div><p class="field-label">Date</p><p class="field-value">${formatDate(audit.taskTimestamp)}</p></div>
          <div><p class="field-label">Request Type</p><p class="field-value">${escapeHTML(audit.requestType || 'N/A')}</p></div>
          <div><p class="field-label">Outcome</p><p class="field-value">${audit.outcome || 'N/A'}</p></div>
        </div>
      `;

      // Form metadata
      form.setAttribute('data-audit-id', auditId);
      form.setAttribute('data-reference-number', audit.referenceNumber || '');
      form.setAttribute('data-task-type', audit.taskType || '');
      form.setAttribute('data-outcome', audit.outcome || '');
      window.skipUnlock = false;

      // ✅ Load relevant questions
      loadQuestionsForEvaluation(audit);

      // ✅ Heartbeat safety — clear old interval before starting new one
      if (window.auditHeartbeat) clearInterval(window.auditHeartbeat);
      window.auditHeartbeat = setInterval(() => {
        google.script.run.keepAuditLockAlive(auditId);
        // console.log(`[Heartbeat] Audit ${auditId} pinged at ${new Date().toISOString()}`);
      }, 5 * 60 * 1000); // 5 minutes

      // ✅ Unload handler safety — clear old before registering new
      if (window.boundUnloadUnlockHandler) {
        window.removeEventListener('beforeunload', window.boundUnloadUnlockHandler);
      }

      const unloadHandler = () => {
  // Prevent unlock if misconfigured
  if (!window.skipUnlock) {
    google.script.run.updateAuditStatusAndLock(auditId, 'pending');
  }
};

      window.boundUnloadUnlockHandler = unloadHandler;
      window.addEventListener('beforeunload', unloadHandler);
    })
    .withFailureHandler(function(error) {
      showToast(error.message || 'This audit is currently locked by another user.', 'warning');
      resetEvaluationForm();
      showAuditQueue();
      loadPendingTasks();
    })
    .prepareEvaluation(auditId);
}

function loadQuestionsForEvaluation(audit, attempt = 1) {
  const maxRetries = 5;
  const questionsContainer = document.getElementById('questions');
  const form = document.getElementById('evaluationForm');

  if (!questionsContainer) {
    if (attempt < maxRetries) {
      return setTimeout(() => loadQuestionsForEvaluation(audit, attempt + 1), 300);
    } else {
      alert('Failed to load questions. Please return to the Audit Queue and try again.');
      return;
    }
  }

  questionsContainer.innerHTML = '<div class="loading">Loading questions...</div>';

  google.script.run.withSuccessHandler(function (questions) {
    let maxPossibleScore = 0;
    questionsContainer.innerHTML = '';

    if (!questions || questions.length === 0) {
      // 🧠 Inline UX update + countdown message
      questionsContainer.innerHTML = `
        <div class="alert alert-warning" style="margin-top: 1rem;">
          ⚠️ No evaluation questions are configured for this request type and task type.
          <br>Please contact your QA admin.
          <br><br><em>Returning to the Audit Queue in <span id="redirectCountdown">5</span> seconds...</em>
        </div>
      `;

      // 🛑 Prevent form submission
      form.classList.add('disabled');

      // ✅ Prevent automatic unlock — misconfigured
      window.skipUnlock = true;

      // ✅ Log misconfiguration (updated to pass all required values)
      markAuditAsMisconfigured(
        audit.auditId,
        audit.requestType,
        audit.taskType
      );

      // ✅ Show toast message
      showToast("No evaluation questions are set up for this record.", 'warning');

      // 🕒 Start 5-second redirect countdown
      let secondsLeft = 5;
      const countdownEl = document.getElementById('redirectCountdown');
      const countdownTimer = setInterval(() => {
        secondsLeft--;
        if (countdownEl) countdownEl.textContent = secondsLeft;
        if (secondsLeft <= 0) {
          clearInterval(countdownTimer);
          showAuditQueue();
        }
      }, 1000);

      return;
    }

    // ✅ Normal path: render all questions
    questions.forEach(q => {
      maxPossibleScore += parseInt(q.pointsPossible || 0);

      const questionCard = document.createElement('div');
      questionCard.className = 'question-card';
      questionCard.setAttribute('data-question-id', q.id);
      questionCard.setAttribute('data-question-text', q.questionText);
      questionCard.setAttribute('data-points-possible', q.pointsPossible);

      questionCard.innerHTML = `
        <div class="question-header">
          <h3 class="question-text">${q.questionText}</h3>
          <span class="question-points">Points: ${q.pointsPossible}</span>
        </div>
        <div class="question-body">
          <div class="radio-group">
            <label><input type="radio" name="question_${q.id}" value="yes"> <span>Yes</span></label>
            <label><input type="radio" name="question_${q.id}" value="no"> <span>No</span></label>
          </div>
          <div class="feedback-field">
            <label for="feedback_${q.id}">Specific Feedback:</label>
            <textarea id="feedback_${q.id}" name="feedback_${q.id}" rows="2" class="form-control"></textarea>
          </div>
        </div>
      `;
      questionsContainer.appendChild(questionCard);
    });

    form.setAttribute('data-max-score', maxPossibleScore);
    form.classList.remove('disabled');
  }).getQuestionsBySet(audit.requestType, audit.taskType);
}

function markAuditAsMisconfigured(auditId, requestType, taskType) {
  if (!auditId || !requestType || !taskType) return;

  google.script.run
    .withSuccessHandler(count => {
      showToast(`Marked ${count} audits as misconfigured for this task.`, 'warning');
    })
    .markAuditAsMisconfigured(auditId, requestType, taskType);
}

  function handleEvaluationSubmit(e) {
  e.preventDefault();

  const form = document.getElementById('evaluationForm');
  const submitButton = document.getElementById('submitEvaluationBtn');
  if (!form) return showToast("Evaluation form not found.", 'error');

  if (form.classList.contains('disabled')) {
    showToast("Please wait for the questions to finish loading.", 'warning');
    return;
  }

  const auditId = form.getAttribute('data-audit-id');
  const referenceNumber = form.getAttribute('data-reference-number');
  const taskType = form.getAttribute('data-task-type');
  const outcome = form.getAttribute('data-outcome');
  const feedbackField = document.getElementById('feedback');
  const feedback = feedbackField ? feedbackField.value : '';

  // Validation: all questions must be answered
  let allAnswered = true;
  document.querySelectorAll('#questions .question-card').forEach(card => {
    const questionId = card.getAttribute('data-question-id');
    const selected = card.querySelector(`input[name="question_${questionId}"]:checked`);
    if (!selected) allAnswered = false;
  });

  if (!allAnswered) {
    showToast("Please answer all questions before submitting the evaluation.", 'warning');
    return;
  }

  // Compile responses — let server calculate scores
  const questions = [];
  document.querySelectorAll('.question-card').forEach(card => {
    const questionId = card.getAttribute('data-question-id');
    const questionText = card.getAttribute('data-question-text');
    const pointsPossible = parseInt(card.getAttribute('data-points-possible') || 0);
    const selected = card.querySelector(`input[name="question_${questionId}"]:checked`);
    const response = selected ? selected.value : 'no';
    const feedbackInput = document.getElementById(`feedback_${questionId}`);
    const feedback = feedbackInput ? feedbackInput.value : '';

    if (questionId && questionText) {
      questions.push({
        questionId,
        questionText,
        response,
        pointsPossible,
        feedback
      });
    }
  });

  const evaluationData = {
    auditId,
    referenceNumber,
    taskType,
    outcome,
    qaEmail: '',
    startTimestamp: new Date().toISOString(),
    feedback,
    questions
  };

  // UI: loading state
  form.classList.add('hidden');
  const loadingIndicator = document.createElement('div');
  loadingIndicator.id = 'evaluationLoadingIndicator';
  loadingIndicator.className = 'loading';
  loadingIndicator.innerText = 'Saving evaluation...';
  document.getElementById('evaluationFormView').appendChild(loadingIndicator);
  submitButton.disabled = true;

  // Final check to prevent duplicate submission
  google.script.run
    .withSuccessHandler(alreadyEvaluated => {
      if (alreadyEvaluated) {
        showToast("This audit has already been evaluated by another user.", 'warning');
        document.getElementById('evaluationLoadingIndicator')?.remove();
        submitButton.disabled = false;
        form.classList.remove('hidden');
        showAuditQueue();
        return;
      }

      google.script.run
        .withSuccessHandler(() => {
          updateAuditStatusAndLock(auditId, 'evaluated')
            .then(() => {
              clearInterval(window.auditHeartbeat);
              window.removeEventListener('beforeunload', window.boundUnloadUnlockHandler);
              delete window.boundUnloadUnlockHandler;

              showToast("Evaluation saved successfully!", 'success');
              resetEvaluationForm();
              document.getElementById('evaluationLoadingIndicator')?.remove();
              submitButton.disabled = false;
              form.classList.remove('hidden');
              showAuditQueue();
            })
            .catch(err => {
              console.error('Audit status update error:', err);
              showToast("Failed to unlock record. Try again.", 'error');
              document.getElementById('evaluationLoadingIndicator')?.remove();
              submitButton.disabled = false;
              form.classList.remove('hidden');
            });
        })
        .withFailureHandler(error => {
          showToast("Error saving evaluation: " + error.message, 'error');
          document.getElementById('evaluationLoadingIndicator')?.remove();
          submitButton.disabled = false;
          form.classList.remove('hidden');
        })
        .saveEvaluation(evaluationData);
    })
    .withFailureHandler(error => {
      console.error('Error checking evaluation status:', error);
      showToast("Could not verify evaluation status. Please try again.", 'error');
      document.getElementById('evaluationLoadingIndicator')?.remove();
      submitButton.disabled = false;
      form.classList.remove('hidden');
    })
    .checkIfAlreadyEvaluated(auditId);
}

function resetEvaluationForm() {
  const form = document.getElementById('evaluationForm');
  if (!form) return;

  form.reset(); // Clear all inputs

  const questionsContainer = document.getElementById('questions');
  if (questionsContainer) questionsContainer.innerHTML = '';

  const feedbackField = document.getElementById('feedback');
  if (feedbackField) feedbackField.value = '';

  // Remove audit-specific metadata
  ['data-audit-id', 'data-reference-number', 'data-task-type', 'data-outcome', 'data-max-score'].forEach(attr =>
    form.removeAttribute(attr)
  );

  // Hide the evaluation form view (optional, but improves UX)
  document.getElementById('evaluationFormView')?.classList.add('hidden');

  // Remove loading indicator if still present
  document.getElementById('evaluationLoadingIndicator')?.remove();
}

function loadEvaluations() {
  const tableBody = document.getElementById('evaluationsBody');
  tableBody.innerHTML = '<tr><td colspan="6" class="text-center">Loading...</td></tr>';

  google.script.run.withSuccessHandler(function(evaluations) {
    google.script.run.withSuccessHandler(function(disputesQueue) {
      const disputedEvalIds = new Set(disputesQueue.map(d => d.evalId));
      const pendingReviewingEvalIds = new Set(
        disputesQueue.filter(d => d.status === 'pending' || d.status === 'reviewing').map(d => d.evalId)
      );

      tableBody.innerHTML = '';
      evaluations.forEach(e => {
        const percentage = Math.round((e.totalPoints / e.totalPointsPossible) * 100);
        let scoreClass = 'score-high';
        if (percentage < 70) scoreClass = 'score-low';
        else if (percentage < 90) scoreClass = 'score-medium';

        let rowClass = '';
        if (e.status === 'pending' || e.status === 'reviewing') rowClass = 'highlight-pending-reviewing';

        const row = document.createElement('tr');
        row.className = rowClass;
        row.innerHTML = `
          <td>${formatTaskType(e.taskType)}</td>
          <td>${e.qaEmail}</td>
          <td>${formatDate(e.stopTimestamp)}</td>
          <td class="evaluation-score ${scoreClass}">${e.totalPoints}/${e.totalPointsPossible} (${percentage}%)</td>
          <td><span class="badge badge-${e.status}">${e.status}</span></td>
          <td>
            <button class="btn btn-sm btn-primary view-evaluation-button" data-evaluation-id="${e.id}">View</button>
            ${e.status === 'completed' && !disputedEvalIds.has(e.id) && percentage < 100
              ? `<button class="btn btn-sm btn-danger ml-2 dispute-button" data-evaluation-id="${e.id}">Dispute</button>`
              : ''}
          </td>
        `;
        tableBody.appendChild(row);
      });

      // View Evaluation
      document.querySelectorAll('.view-evaluation-button').forEach(btn =>
        btn.addEventListener('click', () => {
          const evaluationId = btn.getAttribute('data-evaluation-id');
          viewEvaluation(evaluationId);
        })
      );

      // Dispute Evaluation
      document.querySelectorAll('.dispute-button').forEach(btn =>
        btn.addEventListener('click', () => {
          const button = btn;
          const evalId = button.dataset.evaluationId;
          const originalHTML = button.innerHTML;

          button.disabled = true;
          button.innerHTML = `<span class="spinner"></span>Checking...`;

          // ✅ Set modal message and show modal
          const modal = document.getElementById('evaluateModal');
          document.getElementById('evaluateModalMessage').textContent = 'Validating dispute availability...';
          modal?.classList.remove('hidden');

          google.script.run
            .withSuccessHandler(function(result) {
              modal?.classList.add('hidden');
              button.disabled = false;
              button.innerHTML = originalHTML;

              if (!result.success) {
                const status = String(result.status || '').toLowerCase();
                const msg =
                  status === 'reviewing'
                    ? "This evaluation is currently being reviewed by another user."
                    : status === 'disputed'
                    ? "This evaluation has already been disputed."
                    : "This evaluation is not available for dispute.";
                showToast(msg, 'warning');
                showEvaluations();
                loadCompletedEvaluations();
                return;
              }

              showDisputeForm(evalId);
            })
            .withFailureHandler(function(error) {
              modal?.classList.add('hidden');
              console.error("Error checking dispute status:", error);
              showToast("Unable to validate dispute status. Try again.", "error");
              button.disabled = false;
              button.innerHTML = originalHTML;
            })
            .checkAndSetDisputeReviewStatus(evalId);
        })
      );
    }).getAllDisputes();
  }).getAllEvaluations();
}

  function viewEvaluation(evaluationId) {
  hideAllViews();
  document.getElementById('viewEvaluationView').classList.remove('hidden');

  google.script.run.withSuccessHandler(function(evaluations) {
    const evaluation = evaluations.find(e => e.id === evaluationId);
    if (!evaluation) return alert("Evaluation not found.");

    document.getElementById('viewEvaluationDetails').innerHTML = `
      <div class="grid-2">
        <div><p class="field-label">Task Type</p><p class="field-value">${formatTaskType(evaluation.taskType)}</p></div>
        <div><p class="field-label">Date</p><p class="field-value">${formatDate(evaluation.stopTimestamp)}</p></div>
        <div><p class="field-label">Reference</p><p class="field-value">${evaluation.referenceNumber || 'N/A'}</p></div>
        <div><p class="field-label">QA Agent</p><p class="field-value">${evaluation.qaEmail}</p></div>
        <div class="grid-span-2"><p class="field-label">Feedback</p><p class="field-value">${evaluation.feedback || 'No feedback provided.'}</p></div>
      </div>
    `;

    const container = document.getElementById('viewEvaluationQuestions');
    container.innerHTML = '';

    evaluation.questions.forEach(q => {
      const highlightClass = q.response === 'no' ? 'highlight-no' : '';
      container.innerHTML += `
        <div class="question-card ${highlightClass}">
          <div class="question-header">
            <h3 class="question-text">${q.questionText}</h3>
            <span class="question-points">Score: ${q.pointsEarned}/${q.pointsPossible}</span>
          </div>
          <div class="question-body">
            <p class="field-label">Response:</p>
            <p class="field-value">${q.response === 'yes' ? 'Yes' : 'No'}</p>
            ${q.feedback ? `<p class="field-label">Feedback:</p><p class="field-value">${q.feedback}</p>` : ''}
          </div>
        </div>
      `;
    });
  }).getAllEvaluations();
}

function loadDisputes() {
  const tableBody = document.getElementById('disputesBody');
  tableBody.innerHTML = '<tr><td colspan="5" class="text-center">Loading...</td></tr>';

  google.script.run.withSuccessHandler(function(disputes) {
    if (!Array.isArray(disputes) || disputes.length === 0) {
      tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-gray-500">No disputes found</td></tr>';
      return;
    }

    tableBody.innerHTML = '';

    disputes.forEach(function(dispute) {
      const status = (dispute.status || '').toLowerCase();
      const isResolved = ['overturned', 'upheld', 'partial overturn'].includes(status);
      const row = document.createElement('tr'); // ✅ FIXED

      row.innerHTML = `
        <td>Evaluation #${dispute.evalId}</td>
        <td>${dispute.userEmail}</td>
        <td>${formatDate(dispute.disputeTimestamp)}</td>
        <td><span class="badge badge-${status}">${dispute.status}</span></td>
        <td>
          <button class="view-dispute-button btn btn-sm btn-secondary" data-dispute-id="${dispute.id}">View</button>
          ${isResolved
            ? `<button class="edit-dispute-button btn btn-sm btn-primary-edit" data-dispute-id="${dispute.id}">Edit Resolution</button>`
            : `<button class="resolve-dispute-button btn btn-sm btn-primary" data-dispute-id="${dispute.id}">Resolve Dispute</button>`
          }
        </td>
      `;

      tableBody.appendChild(row);
    });

    // ✅ View button
    document.querySelectorAll('.view-dispute-button').forEach(button => {
      button.addEventListener('click', function () {
        const id = this.getAttribute('data-dispute-id');
        viewDispute(id);
      });
    });

    // ✅ Resolve Dispute button
    document.querySelectorAll('.resolve-dispute-button').forEach(button => {
      button.addEventListener('click', function () {
        const button = this;
        const disputeId = button.getAttribute('data-dispute-id');

        const modal = document.getElementById('evaluateModal');
        if (modal) {
          document.getElementById('evaluateModalMessage').textContent = 'Checking dispute status...';
          modal.classList.remove('hidden');
        }

        google.script.run
          .withSuccessHandler(function(result) {
            modal?.classList.add('hidden');
            const status = (result?.status || '').toLowerCase();

            if (['overturned', 'upheld', 'partial overturn'].includes(status)) {
              showToast("This dispute has already been resolved.", 'warning');
              loadDisputes();
              return;
            }

            if (status === 'reviewing') {
              showToast("This dispute is currently being reviewed by another user.", 'warning');
              loadDisputes();
              return;
            }

            resolveDispute(disputeId);
          })
          .withFailureHandler(function(error) {
            modal?.classList.add('hidden');
            console.error("Dispute status check failed:", error);
            showToast("Unable to validate dispute status. Please try again.", 'error');
          })
          .checkDisputeReviewStatus(disputeId);
      });
    });

    // ✅ Edit Resolution button
    document.querySelectorAll('.edit-dispute-button').forEach(button => {
      button.addEventListener('click', function () {
        const id = this.getAttribute('data-dispute-id');
        editDisputeResolution(id);
      });
    });

  }).getAllDisputes();
}

function editDisputeResolution(disputeId) {
  hideAllViews();
  const resolveDisputeView = document.getElementById('resolveDisputeView');
  resolveDisputeView.classList.remove('hidden');
  resolveDisputeView.innerHTML = '';

  google.script.run.withSuccessHandler(function(data) {
    const dispute = data.disputes.find(d => d.id === disputeId);
    const evaluation = data.evaluations.find(e => e.id === dispute.evalId || e.evalId === dispute.evalId);

    if (!dispute || !evaluation) {
      showToast("Dispute or evaluation not found.", 'error');
      return;
    }

    // Normalize questionIds
    if (typeof dispute.questionIds === 'string') {
      dispute.questionIds = dispute.questionIds.split(',').map(id => id.trim()).filter(Boolean);
    }

    // ✅ Track for unload/cancel restore
    activeDisputeResolutionId = dispute.id;
    window.originalDisputeStatus = dispute.status;

    attachUnloadHandlerForDisputeResolution(dispute.id);

    // Set status to reviewing
    google.script.run.updateDisputeStatus(dispute.id, 'reviewing');

    // Render view
    resolveDisputeView.innerHTML = `
      <div class="card">
        <h2>Edit Dispute Resolution</h2>
        <div id="resolveEvaluationDetails" class="mb-4">Loading...</div>

        <form id="resolveDisputeForm">
          <div id="resolveDisputeQuestions" class="questions-container mb-4">Loading questions...</div>

          <div class="form-group mt-3">
            <label for="resolutionNotes">General Notes (optional)</label>
            <textarea id="resolutionNotes" name="resolutionNotes" rows="3" class="form-control">${dispute.resolutionNotes || ''}</textarea>
          </div>

          <div class="button-group">
            <button type="button" id="cancelResolveDispute" class="btn btn-secondary">Cancel</button>
            <button type="submit" class="btn btn-primary">Submit Resolution</button>
          </div>
        </form>
      </div>
    `;

    // Set form attributes + listener
    const form = document.getElementById('resolveDisputeForm');
    form.setAttribute('data-eval-id', evaluation.id);
    form.setAttribute('data-dispute-id', dispute.id);
    form.addEventListener('submit', handleEditDisputeResolutionSubmit);

    // Cancel button with restore
    document.getElementById('cancelResolveDispute').addEventListener('click', function () {
      const modal = document.getElementById('evaluateModal');
      if (modal) {
        document.getElementById('evaluateModalMessage').textContent = 'Restoring dispute status...';
        modal.classList.remove('hidden');
      }

      google.script.run
        .withSuccessHandler(() => {
          modal?.classList.add('hidden');
          showToast(`Dispute status restored to "${window.originalDisputeStatus}"`, 'info');
          removeUnloadHandlerForDisputeResolution();
          delete window.originalDisputeStatus;
          activeDisputeResolutionId = null;
          showDisputes();
        })
        .withFailureHandler(error => {
          modal?.classList.add('hidden');
          console.error('Error restoring dispute status:', error);
          showToast('Failed to restore dispute status: ' + error.message, 'error');
        })
        .updateDisputeStatus(dispute.id, window.originalDisputeStatus || 'pending');
    });

    // Display evaluation context
    document.getElementById('resolveEvaluationDetails').innerHTML = `
      <div class="grid-2">
        <div><p class="field-label">Reference</p><p class="field-value">${evaluation.referenceNumber}</p></div>
        <div><p class="field-label">Task Type</p><p class="field-value">${formatTaskType(evaluation.taskType)}</p></div>
        <div><p class="field-label">QA Agent</p><p class="field-value">${evaluation.qaEmail}</p></div>
        <div><p class="field-label">Dispute Reason</p><p class="field-value">${dispute.reason}</p></div>
      </div>
    `;

    // Render questions
    const container = document.getElementById('resolveDisputeQuestions');
    container.innerHTML = '';

    evaluation.questions.forEach(q => {
      const qid = String(q.questionId).trim();
      const isDisputed = dispute.questionIds.includes(qid);
      let highlightClass = '';
      if (isDisputed && q.response === 'yes') highlightClass = 'overturned-highlight';
      else if (isDisputed && q.response === 'no') highlightClass = 'highlight-no';

      const currentResponse = String(q.response || '').toLowerCase();
      const yesChecked = currentResponse === 'yes' ? 'checked' : '';
      const noChecked = currentResponse === 'no' ? 'checked' : '';

      const card = document.createElement('div');
      card.className = `question-card ${highlightClass}`;
      card.innerHTML = `
        <div class="question-header">
          <h3 class="question-text">${q.questionText}</h3>
          <span class="question-points">Current: ${q.pointsEarned}/${q.pointsPossible}</span>
        </div>
        <div class="question-body">
          <div class="radio-group">
            <label>
              <input type="radio" name="edit_${qid}" value="yes" ${yesChecked}>
              <span>Yes</span>
            </label>
            <label>
              <input type="radio" name="edit_${qid}" value="no" ${noChecked}>
              <span>No</span>
            </label>
          </div>

          ${isDisputed ? `
            <div class="alert alert-info mt-2">
              This question was previously part of a dispute resolution.
            </div>` : ''}

          <div class="form-group mt-2">
            <label for="editNote_${qid}">Optional Notes</label>
            <textarea class="form-control" id="editNote_${qid}" name="editNote_${qid}" rows="2">${q.feedback || ''}</textarea>
          </div>
        </div>
      `;
      container.appendChild(card);
    });
  }).getAllEvaluationsAndDisputes();
}

function handleEditDisputeResolutionSubmit(e) {
  e.preventDefault();

  const form = e.target;
  const evalId = form.getAttribute('data-eval-id');
  const disputeId = form.getAttribute('data-dispute-id');
  const resolutionNotes = document.getElementById('resolutionNotes')?.value.trim() || '';

  const questions = [];
  let overturnCount = 0;

  const cards = document.querySelectorAll('#resolveDisputeQuestions .question-card');
  cards.forEach(card => {
    const qid = card.getAttribute('data-question-id');
    const selected = card.querySelector(`input[name="edit_${qid}"]:checked`);
    const note = document.getElementById(`editNote_${qid}`)?.value.trim() || '';

    if (!selected) {
      showToast(`Please select a response for all questions.`, 'warning');
      return;
    }

    const response = selected.value.toLowerCase();
    const pointsPossible = parseInt(card.getAttribute('data-points-possible') || 0);
    const pointsEarned = response === 'yes' ? pointsPossible : 0;

    if (response === 'yes') overturnCount++;

    questions.push({
      questionId: qid,
      questionText: card.getAttribute('data-question-text'),
      response,
      pointsEarned,
      pointsPossible,
      feedback: note
    });
  });

  if (questions.length !== cards.length) return; // 👮 prevent partial submission

  // Calculate final status based on overturned questions
  let status = 'upheld';
  if (overturnCount === questions.length) status = 'overturned';
  else if (overturnCount > 0) status = 'partial overturn';

  const resolutionData = { disputeId, evalId, resolutionNotes, decisions: questions, status };

  // UI: show spinner
  form.classList.add('disabled');
  const submitBtn = form.querySelector('button[type="submit"]');
  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.innerHTML = `<span class="spinner"></span>Saving...`;
  }
  document.getElementById('evaluateModalMessage').textContent = 'Saving updated resolution...';
  document.getElementById('evaluateModal')?.classList.remove('hidden');

  // ✅ Show summary modal instead of saving immediately
window.pendingEditResolution = {
  form,
  evalId,
  disputeId,
  resolutionNotes,
  questions,
  overturnCount
};

buildEditResolutionSummaryPreview(questions, overturnCount, form);

function buildEditResolutionSummaryPreview(questions, overturnCount, form) {
  const summaryModal = document.getElementById('resolutionSummaryModal');
  const summaryContent = document.getElementById('summaryContent');
  const scorePreview = document.getElementById('summaryScorePreview');
  const confirmBtn = document.getElementById('confirmResolutionSubmit');
  const cancelBtn = document.getElementById('cancelResolutionSubmit');
  const evalModal = document.getElementById('evaluateModal');
  const evalModalMessage = document.getElementById('evaluateModalMessage');

  if (!summaryModal || !summaryContent || !scorePreview) {
    console.error('Missing summary modal elements');
    return;
  }

  // Build summary
  let summaryHtml = '';
  let totalEarned = 0;
  let totalPossible = 0;

  questions.forEach(q => {
    const earned = q.pointsEarned || 0;
    const possible = q.pointsPossible || 0;
    totalEarned += earned;
    totalPossible += possible;

    const icon = q.response === 'yes' ? '✔️' : '✖️';
    const colorStyle = q.response === 'yes' ? 'color: #15803d;' : 'color: #b91c1c;';

    summaryHtml += `
      <div style="margin-bottom: 0.75rem;">
        <div style="${colorStyle}">
          ${icon} <strong>${q.questionText}</strong>
        </div>
        <div style="margin-left: 1.25rem; font-size: 0.85rem; color: #6b7280;">
          Answer: ${q.response.toUpperCase()}<br>
          Points: ${earned}/${possible}
        </div>
      </div>
    `;
  });

  // Set % preview
  const percent = totalPossible > 0 ? Math.round((totalEarned / totalPossible) * 100) : 0;
  scorePreview.textContent = `${percent}%`;
  summaryContent.innerHTML = summaryHtml;
  summaryModal.classList.remove('hidden');

  // Attach handlers once
  if (!confirmBtn.dataset.bound) {
    confirmBtn.addEventListener('click', function () {
      summaryModal.classList.add('hidden');

      const data = window.pendingEditResolution;
      if (!data) return;

      const { form, evalId, disputeId, resolutionNotes, questions, overturnCount } = data;

      const total = questions.length;
      let status = 'upheld';
      if (overturnCount === total && total > 0) status = 'overturned';
      else if (overturnCount > 0) status = 'partial overturn';

      const resolutionData = { disputeId, evalId, resolutionNotes, decisions: questions, status };

      // Show spinner modal
      if (evalModal && evalModalMessage) {
        evalModalMessage.textContent = 'Saving updated resolution...';
        evalModal.classList.remove('hidden');
      }

      google.script.run
        .withSuccessHandler(() => {
          evalModal?.classList.add('hidden');
          showToast("Dispute resolution updated.", 'success');
          removeUnloadHandlerForDisputeResolution();
          delete window.originalDisputeStatus;
          window.pendingEditResolution = null;
          activeDisputeResolutionId = null;
          showDisputes();
        })
        .withFailureHandler(err => {
          console.error('Failed to update resolution:', err);
          showToast('Failed to update resolution: ' + err.message, 'error');
          evalModal?.classList.add('hidden');
          form.classList.remove('disabled');
          const btn = form.querySelector('button[type="submit"]');
          if (btn) {
            btn.disabled = false;
            btn.textContent = 'Submit Resolution';
          }
        })
        .resolveDispute(resolutionData);
    });
    confirmBtn.dataset.bound = 'true';
  }

  if (!cancelBtn.dataset.bound) {
  cancelBtn.addEventListener('click', closeSummaryModal);
  cancelBtn.dataset.bound = 'true';
}

// Click outside modal content
if (!summaryModal.dataset.outsideListenerAttached) {
  summaryModal.addEventListener('click', function (e) {
    if (e.target === summaryModal) {
      closeSummaryModal();
    }
  });
  summaryModal.dataset.outsideListenerAttached = 'true';
}

// Escape key
if (!window.summaryEscListenerAttached) {
  window.addEventListener('keydown', function (e) {
    if (e.key === 'Escape' && !summaryModal.classList.contains('hidden')) {
      closeSummaryModal();
    }
  });
  window.summaryEscListenerAttached = true;
}

// Helper to fully close the summary modal
function closeSummaryModal() {
  summaryModal.classList.add('hidden');

  const data = window.pendingEditResolution;
  if (data?.form) {
    data.form.classList.remove('disabled');
    const btn = data.form.querySelector('button[type="submit"]');
    if (btn) {
      btn.disabled = false;
      btn.textContent = 'Submit Resolution';
    }
  }
}
}

function submitEditedResolution(form, resolutionData) {
  const submitBtn = form.querySelector('button[type="submit"]');
  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.innerHTML = `<span class="spinner"></span>Submitting...`;
  }
  form.classList.add('disabled');
  document.getElementById('evaluateModal')?.classList.remove('hidden');

  google.script.run
    .withSuccessHandler(() => {
      document.getElementById('evaluateModal')?.classList.add('hidden');
      showToast("Resolution updated successfully.", "success");
      removeUnloadHandlerForDisputeResolution();
      showDisputes();
    })
    .withFailureHandler(error => {
      console.error("Resolution update failed:", error);
      showToast("Failed to update resolution: " + error.message, "error");
      document.getElementById('evaluateModal')?.classList.add('hidden');
      form.classList.remove('disabled');
      if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Resolution';
      }
    })
    .resolveDispute(resolutionData);
}

function viewDispute(disputeId) {
  hideAllViews();
  document.getElementById('resolveDisputeView').classList.remove('hidden');

  google.script.run.withSuccessHandler(function(data) {
    const dispute = data.disputes.find(d => d.id === disputeId);
    const evaluation = data.evaluations.find(e => e.id === dispute.evalId || e.evalId === dispute.evalId);

    if (!dispute || !evaluation) {
      showToast("Dispute or evaluation not found.", 'error');
      return;
    }

    // Inject HTML structure for the view mode
    document.getElementById('resolveDisputeView').innerHTML = `
      <div class="card">
        <h2>View Dispute</h2>
        <div id="resolveEvaluationDetails" class="mb-4">Loading...</div>

        <form id="resolveDisputeForm">
          <div id="resolveDisputeQuestions" class="questions-container mb-4">Loading questions...</div>

          <div class="button-group">
            <button type="button" id="cancelResolveDispute" class="btn btn-secondary">Cancel</button>
          </div>
        </form>
      </div>
    `;

    const form = document.getElementById('resolveDisputeForm');
    form.setAttribute('data-eval-id', evaluation.id);
    form.setAttribute('data-dispute-id', dispute.id);

    // Attach the cancel handler
    document.getElementById('cancelResolveDispute').addEventListener('click', showDisputes);

    // Render evaluation metadata
    const detailsHTML = `
      <div class="grid-2">
        <div><p class="field-label">Reference</p><p class="field-value">${evaluation.referenceNumber}</p></div>
        <div><p class="field-label">Task Type</p><p class="field-value">${formatTaskType(evaluation.taskType)}</p></div>
        <div><p class="field-label">QA Agent</p><p class="field-value">${evaluation.qaEmail}</p></div>
        <div><p class="field-label">Dispute Reason</p><p class="field-value">${dispute.reason}</p></div>
      </div>
    `;
    document.getElementById('resolveEvaluationDetails').innerHTML = detailsHTML;

    // Render disputed questions
    const container = document.getElementById('resolveDisputeQuestions');
    container.innerHTML = '';

    evaluation.questions.forEach(q => {
    const qid = String(q.questionId).trim();
    if (!qid || !q.questionText) return;

    if (!Array.isArray(dispute.questionIds)) {
      console.warn('🚫 dispute.questionIds is not an array:', dispute.questionIds);
      return;
    }

    if (!dispute.questionIds.includes(qid)) {
      console.log(`⛔ Skipping question ${qid} — not in dispute list:`, dispute.questionIds);
      return;
    }

      const highlightClass = q.response === 'no' ? 'highlight-no' : '';
      const card = document.createElement('div');
      card.className = `question-card ${highlightClass}`;
      card.innerHTML = `
        <div class="question-header">
          <h3 class="question-text">${q.questionText}</h3>
          <span class="question-points">Original: ${q.pointsEarned}/${q.pointsPossible}</span>
        </div>
        <div class="question-body">
          <p class="field-label">Response:</p>
          <p class="field-value">${q.response === 'yes' ? 'Yes' : 'No'}</p>
        </div>
      `;
      container.appendChild(card);
    });
  }).getAllEvaluationsAndDisputes();
}

function showDisputeForm(evaluationId) {
  hideAllViews();

  const disputeFormView = document.getElementById('disputeFormView');
  disputeFormView.classList.remove('hidden');

  // 🔄 Rebuild the form HTML to reset previous "Submitting..." or stale state
  disputeFormView.innerHTML = `
    <div class="card">
      <h2>Dispute Evaluation</h2>
      <p>Please provide the details for your dispute below. Ensure all required fields are filled out.</p>
      <div id="evaluationDetails" class="evaluation-details mb-4">Loading evaluation details...</div>

      <form id="disputeForm">
        <div id="disputeQuestions" class="questions-container mb-4">Loading questions...</div>

        <div class="form-group mb-4">
          <label for="disputeReason">Reason for Dispute <span class="required">*</span></label>
          <textarea id="disputeReason" name="disputeReason" rows="3" class="form-control" required></textarea>
          <div class="invalid-feedback">Please provide a reason for the dispute.</div>
        </div>

        <div class="button-group">
          <button type="button" id="cancelDispute" class="btn btn-secondary">Cancel</button>
          <button type="submit" class="btn btn-primary">Submit Dispute</button>
        </div>
      </form>
    </div>
  `;

  // 🧩 Re-attach event listeners after DOM was rebuilt
  document.getElementById('cancelDispute').addEventListener('click', () => {
    removeUnloadHandlerForDispute(); // ✅ cleanup on cancel
    showEvaluations();
  });

  document.getElementById('disputeForm').addEventListener('submit', handleDisputeSubmit);

  // 🔍 Load evaluation details and questions
  google.script.run.withSuccessHandler(function(evaluations) {
    const evaluation = evaluations.find(e => e.id === evaluationId);

    if (!evaluation) {
      console.error("Evaluation not found:", evaluationId);
      return;
    }

    const scorePercentage = Math.round((evaluation.totalPoints / evaluation.totalPointsPossible) * 100);

    document.getElementById('evaluationDetails').innerHTML = `
      <div class="grid-2">
        <div>
          <p class="field-label">Task Type</p>
          <p class="field-value">${formatTaskType(evaluation.taskType)}</p>
        </div>
        <div>
          <p class="field-label">Evaluation Date</p>
          <p class="field-value">${formatDate(evaluation.stopTimestamp)}</p>
        </div>
        <div>
          <p class="field-label">Reference Number</p>
          <p class="field-value">${evaluation.referenceNumber || 'N/A'}</p>
        </div>
        <div>
          <p class="field-label">Score</p>
          <p class="field-value">${evaluation.totalPoints}/${evaluation.totalPointsPossible} (${scorePercentage}%)</p>
        </div>
        <div class="grid-span-2">
          <p class="field-label">Feedback</p>
          <p class="field-value">${evaluation.feedback || 'No feedback provided.'}</p>
        </div>
      </div>
    `;

    document.getElementById('disputeForm').setAttribute('data-evaluation-id', evaluationId);

    // ✅ Load questions for dispute
    loadQuestionsForDispute(evaluation);

    // ✅ Attach unload safeguard to revert evaluation status if user exits
    attachUnloadHandlerForDispute(evaluationId);
    activeDisputeEvalId = evaluationId;

  }).getAllEvaluations();
}


  function loadQuestionsForDispute(evaluation) {
  const container = document.getElementById('disputeQuestions');
  container.innerHTML = '';

  if (!evaluation.questions.length) {
    container.innerHTML = '<div class="alert alert-warning">No questions found for this evaluation.</div>';
    return;
  }

  evaluation.questions.forEach(q => {
    const highlightClass = q.response === 'no' ? 'highlight-no' : '';
    const feedbackHtml = q.feedback ? `<p class="field-label">Feedback:</p><p class="field-value">${q.feedback}</p>` : '';

    const card = document.createElement('div');
    card.className = `question-card ${highlightClass}`;
    card.innerHTML = `
      <div class="question-header">
        <h3 class="question-text">${q.questionText}</h3>
        <span class="question-points">Score: ${q.pointsEarned}/${q.pointsPossible}</span>
      </div>
      <div class="question-body">
        <p class="field-label">Response:</p>
        <p class="field-value">${q.response === 'yes' ? 'Yes' : 'No'}</p>
        ${feedbackHtml}
        ${q.response === 'no' ? `
        <div class="dispute-checkbox">
          <label><input type="checkbox" name="dispute_question_${q.questionId}" value="${q.questionId}"> Dispute this question</label>
        </div>` : ''}
      </div>
    `;
    container.appendChild(card);
  });
}

function handleDisputeSubmit(e) {
  e.preventDefault();

  const form = document.getElementById('disputeForm');
  if (!form) return showToast("Dispute form not found.", 'error');

  const evaluationId = form.getAttribute('data-evaluation-id');
  const reasonField = document.getElementById('disputeReason');
  const reason = reasonField ? reasonField.value.trim() : '';

  if (!reason) {
    showToast("Please provide a reason for the dispute.", 'warning');
    return;
  }

  const disputedQuestionIds = Array.from(
    document.querySelectorAll('input[name^="dispute_question_"]:checked')
  ).map(cb => cb.value);

  if (disputedQuestionIds.length === 0) {
    showToast("Please select at least one question to dispute.", 'warning');
    return;
  }

  const disputeData = {
    evalId: evaluationId,
    reason,
    questionIds: disputedQuestionIds,
    status: 'pending'
  };

  // Disable form and show spinner
  form.classList.add('disabled');
  const submitBtn = form.querySelector('button[type="submit"]');
  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.innerHTML = `<span class="spinner"></span>Submitting...`;
  }
  document.getElementById('evaluateModal')?.classList.remove('hidden');

  // Check if already disputed
  google.script.run
    .withSuccessHandler(alreadyDisputed => {
      if (alreadyDisputed) {
        document.getElementById('evaluateModal')?.classList.add('hidden');
        showToast("This evaluation has already been disputed.", 'warning');
        showEvaluations();
        return;
      }

      // ✅ Proceed to submit
      google.script.run
        .withSuccessHandler(() => {
          document.getElementById('evaluateModal')?.classList.add('hidden');
          showToast("Dispute submitted successfully!", 'success');
          removeUnloadHandlerForDispute();
          showEvaluations();
        })
        .withFailureHandler(error => {
          document.getElementById('evaluateModal')?.classList.add('hidden');
          console.error("Error submitting dispute:", error);
          showToast("Error submitting dispute: " + error.message, 'error');
          form.classList.remove('disabled');
          if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Submit Dispute';
          }
        })
        .saveDispute(disputeData);
    })
    .withFailureHandler(error => {
      document.getElementById('evaluateModal')?.classList.add('hidden');
      console.error("Dispute check failed:", error);
      showToast("Could not verify dispute status. Please try again.", 'error');
      form.classList.remove('disabled');
      if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Dispute';
      }
    })
    .checkIfAlreadyDisputed(evaluationId);
}

function resolveDispute(disputeId) {
  hideAllViews();
  const resolveDisputeView = document.getElementById('resolveDisputeView');
  resolveDisputeView.classList.remove('hidden');
  resolveDisputeView.innerHTML = '';

  google.script.run.withSuccessHandler(function(data) {
    const dispute = data.disputes.find(d => d.id === disputeId);
    const evaluation = data.evaluations.find(e => e.id === dispute.evalId || e.evalId === dispute.evalId);

    if (!dispute || !evaluation) {
      showToast("Dispute or evaluation not found.", 'error');
      return;
    }

    // ✅ Track original status for cancel/refresh recovery
    activeDisputeResolutionId = dispute.id;
    window.originalDisputeStatus = dispute.status;

    // ✅ Normalize questionIds
    if (Array.isArray(dispute.questionIds)) {
      // Already valid
    } else if (typeof dispute.questionIds === 'string') {
      dispute.questionIds = dispute.questionIds.split(',').map(id => id.trim()).filter(Boolean);
    } else {
      dispute.questionIds = [];
    }

    // ✅ Setup unload handler for protection
    attachUnloadHandlerForDisputeResolution(dispute.id);

    // ✅ Set to reviewing
    google.script.run.updateDisputeStatus(dispute.id, 'reviewing');

    // ✅ Render form
    resolveDisputeView.innerHTML = `
      <div class="card">
        <h2>Resolve Dispute</h2>
        <div id="resolveEvaluationDetails" class="mb-4">Loading...</div>

        <form id="resolveDisputeForm">
          <div id="resolveDisputeQuestions" class="questions-container mb-4">Loading questions...</div>

          <div class="form-group mt-3">
            <label for="resolutionNotes">General Notes (optional)</label>
            <textarea id="resolutionNotes" name="resolutionNotes" rows="3" class="form-control"></textarea>
          </div>

          <div class="button-group">
            <button type="button" id="cancelResolveDispute" class="btn btn-secondary">Cancel</button>
            <button type="submit" class="btn btn-primary">Submit Resolution</button>
          </div>
        </form>
      </div>
    `;

    // ✅ Populate metadata
    const form = document.getElementById('resolveDisputeForm');
    form.setAttribute('data-eval-id', evaluation.id);
    form.setAttribute('data-dispute-id', dispute.id);
    form.addEventListener('submit', handleResolveDisputeSubmit);

    // ✅ Cancel button: restore prior status
    document.getElementById('cancelResolveDispute').addEventListener('click', function () {
      const modal = document.getElementById('evaluateModal');
      if (modal) {
        document.getElementById('evaluateModalMessage').textContent = 'Restoring dispute status...';
        modal.classList.remove('hidden');
      }

      google.script.run
        .withSuccessHandler(() => {
          modal?.classList.add('hidden');
          showToast(`Dispute status restored to "${window.originalDisputeStatus}"`, 'info');
          removeUnloadHandlerForDisputeResolution();
          delete window.originalDisputeStatus;
          activeDisputeResolutionId = null;
          showDisputes();
        })
        .withFailureHandler(error => {
          modal?.classList.add('hidden');
          console.error('Error restoring dispute status:', error);
          showToast('Failed to restore dispute status: ' + error.message, 'error');
        })
        .updateDisputeStatus(dispute.id, window.originalDisputeStatus || 'pending');
    });

    // ✅ Metadata fields
    document.getElementById('resolveEvaluationDetails').innerHTML = `
      <div class="grid-2">
        <div><p class="field-label">Reference</p><p class="field-value">${evaluation.referenceNumber}</p></div>
        <div><p class="field-label">Task Type</p><p class="field-value">${formatTaskType(evaluation.taskType)}</p></div>
        <div><p class="field-label">QA Agent</p><p class="field-value">${evaluation.qaEmail}</p></div>
        <div><p class="field-label">Dispute Reason</p><p class="field-value">${dispute.reason}</p></div>
      </div>
    `;

    // ✅ Render disputed questions only
    const container = document.getElementById('resolveDisputeQuestions');
    container.innerHTML = '';

    evaluation.questions.forEach(q => {
      const qid = String(q.questionId).trim();
      if (!qid || !q.questionText || !dispute.questionIds.includes(qid)) return;

      const highlightClass = q.response === 'no' ? 'highlight-no' : '';

      const card = document.createElement('div');
      card.className = `question-card ${highlightClass}`;
      card.innerHTML = `
        <div class="question-header">
          <h3 class="question-text">${q.questionText}</h3>
          <span class="question-points">Original: ${q.pointsEarned}/${q.pointsPossible}</span>
        </div>
        <div class="question-body">
          <div class="radio-group">
            <label>
              <input type="radio" name="resolution_${qid}" value="upheld" required>
              <span>Uphold</span>
            </label>
            <label>
              <input type="radio" name="resolution_${qid}" value="overturned">
              <span>Overturn</span>
            </label>
          </div>
          <div class="form-group mt-2">
            <label for="note_${qid}">Justification (required if Upheld)</label>
            <textarea class="form-control" id="note_${qid}" name="note_${qid}" rows="2"></textarea>
          </div>
        </div>
      `;
      container.appendChild(card);
    });
  }).getAllEvaluationsAndDisputes();
}

function handleResolveDisputeSubmit(e) {
  e.preventDefault();

  const form = e.target;
  const evalId = form.getAttribute('data-eval-id');
  const disputeId = form.getAttribute('data-dispute-id');
  const resolutionNotes = document.getElementById('resolutionNotes')?.value.trim() || '';

  const decisions = [];
  let overturnCount = 0;

  const questionCards = document.querySelectorAll('#resolveDisputeQuestions .question-card');

  for (const card of questionCards) {
    const radioInputs = card.querySelectorAll('input[type="radio"]');
    if (!radioInputs.length) continue;

    const questionId = radioInputs[0].name.replace('resolution_', '');
    const selected = form.querySelector(`input[name="resolution_${questionId}"]:checked`);
    const note = form.querySelector(`#note_${questionId}`)?.value.trim() || '';

    if (!selected) {
      showToast("Please select a resolution for all disputed questions.", 'warning');
      return;
    }

    if (selected.value === 'upheld' && !note) {
      showToast("Justification is required when upholding a question.", 'warning');
      return;
    }

    if (selected.value === 'overturned') overturnCount++;

    decisions.push({ questionId, resolution: selected.value, note });
  }

  const total = decisions.length;
  let status = 'upheld';
  if (overturnCount === total && total > 0) status = 'overturned';
  else if (overturnCount > 0) status = 'partial overturn';

  const resolutionData = {
    disputeId,
    evalId,
    resolutionNotes,
    decisions,
    status
  };

  // UI: disable form, show loading spinner
  form.classList.add('disabled');
  const submitBtn = form.querySelector('button[type="submit"]');
  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.innerHTML = `<span class="spinner"></span>Submitting...`;
  }

  const modal = document.getElementById('evaluateModal');
  if (modal) {
    document.getElementById('evaluateModalMessage').textContent = 'Checking dispute status...';
    modal.classList.remove('hidden');
  }

  // ✅ Live check before resolving
  google.script.run
    .withSuccessHandler(serverResult => {
      const normalized = String(serverResult?.status || '').toLowerCase();

      if (['upheld', 'overturned', 'partial overturn'].includes(normalized)) {
        modal?.classList.add('hidden');
        showToast("This dispute has already been resolved.", "warning");
        showDisputes();
        return;
      }

      // ✅ Safe to proceed with resolution
      google.script.run
        .withSuccessHandler(() => {
          modal?.classList.add('hidden');
          showToast('Dispute resolved successfully.', 'success');

          // Clear resolution state trackers
          removeUnloadHandlerForDisputeResolution();
          delete window.originalDisputeStatus;
          activeDisputeResolutionId = null;

          showDisputes();
        })
        .withFailureHandler(error => {
          modal?.classList.add('hidden');
          console.error('Error resolving dispute:', error);
          showToast('Failed to resolve dispute: ' + error.message, 'error');
          form.classList.remove('disabled');
          if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Submit Resolution';
          }
        })
        .resolveDispute(resolutionData);
    })
    .withFailureHandler(err => {
      modal?.classList.add('hidden');
      console.error("Live status check failed:", err);
      showToast("Unable to verify dispute status. Please try again.", "error");
      form.classList.remove('disabled');
      if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Resolution';
      }
    })
    .checkDisputeReviewStatus(disputeId);
}

  function loadUsers() {
  const tableBody = document.getElementById('usersBody');
  tableBody.innerHTML = '<tr><td colspan="5" class="text-center">Loading...</td></tr>';

  google.script.run.withSuccessHandler(function(users) {
    if (!users.length) {
      tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-gray-500">No users found</td></tr>';
      return;
    }

    tableBody.innerHTML = '';
    users.forEach(user => {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${user.name}</td>
        <td>${user.email}</td>
        <td>${formatRole(user.role)}</td>
        <td>${user.managerEmail || 'N/A'}</td>
        <td>
          <button class="edit-user-button btn btn-sm btn-primary" data-user-id="${user.id}">Edit</button>
          <button class="delete-user-button btn btn-sm btn-danger" data-user-id="${user.id}">Delete</button>
        </td>
      `;
      tableBody.appendChild(row);
    });

    // Attach listeners
    document.querySelectorAll('.edit-user-button').forEach(btn =>
      btn.addEventListener('click', () => {
        const userId = btn.getAttribute('data-user-id');
        const user = users.find(u => u.id === userId);
        showUserForm(user);
      })
    );

    document.querySelectorAll('.delete-user-button').forEach(btn =>
      btn.addEventListener('click', () => {
        const userId = btn.getAttribute('data-user-id');
        if (confirm('Delete this user?')) deleteUser(userId);
      })
    );
  }).getAllUsers();
}

  function showUserForm(user = null) {
  const isEdit = !!user;
  document.getElementById('userFormTitle').textContent = isEdit ? 'Edit User' : 'Add User';
  document.getElementById('userId').value = user?.id || '';
  document.getElementById('userFormName').value = user?.name || '';
  document.getElementById('userEmail').value = user?.email || '';
  document.getElementById('userFormRole').value = user?.role || 'agent';
  document.getElementById('userManager').value = user?.managerEmail || '';

  document.getElementById('userForm').classList.remove('hidden');
}

function hideUserForm() {
  document.getElementById('userForm').classList.add('hidden');
}

function handleUserFormSubmit(e) {
  e.preventDefault();
  const userId = document.getElementById('userId').value;
  const userData = {
    id: userId,
    name: document.getElementById('userFormName').value,
    email: document.getElementById('userEmail').value,
    role: document.getElementById('userFormRole').value,
    managerEmail: document.getElementById('userManager').value
  };

  const onSuccess = () => {
    showToast(`User ${userId ? 'updated' : 'created'} successfully!`, 'success');;
    hideUserForm();
    loadUsers();
  };

  const onFailure = err => showToast("Error saving user: " + err.message, 'error');

  if (userId) {
    google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).updateUser(userData);
  } else {
    google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).createUser(userData);
  }
}

function deleteUser(userId) {
  google.script.run
    .withSuccessHandler(() => {
      showToast("User deleted.", 'success');
      loadUsers();
    })
    .withFailureHandler(err => showToast("Error deleting user: " + err.message, 'error'))
    .deleteUser(userId);
}

function loadQuestions() {
  console.log("🔄 loadQuestions triggered");

  google.script.run
    .withSuccessHandler(renderQuestionTable)
    .getAllQuestions();
}

function showQuestionForm(question = null) {
  const form = document.getElementById('questionForm');
  if (!form) return;

  form.reset();
  document.getElementById('questionFormView').classList.remove('hidden');
  document.getElementById('questionFormTitle').textContent = question ? 'Edit Question' : 'Add Question';

  // Set static fields immediately
  document.getElementById('questionId').value = question?.id || '';
  document.getElementById('sequenceId').value = question?.sequenceId || '';
  document.getElementById('pointsPossible').value = question?.pointsPossible || '';
  document.getElementById('questionText').value = question?.questionText || '';

  // Load dropdowns first
  google.script.run.withSuccessHandler(types => {
    const dropdown = document.getElementById('requestTypeDropdown');
    dropdown.innerHTML = '';
    types.forEach(type => {
      const option = document.createElement('option');
      option.value = type;
      option.textContent = type;
      dropdown.appendChild(option);
    });

    // ✅ Set selected value AFTER loading options
    if (question?.requestType) {
      dropdown.value = question.requestType;
    }
  }).getUniqueRequestTypes();

  google.script.run.withSuccessHandler(types => {
    const dropdown = document.getElementById('taskTypeDropdown');
    dropdown.innerHTML = '';
    types.forEach(type => {
      const option = document.createElement('option');
      option.value = type;
      option.textContent = type;
      dropdown.appendChild(option);
    });

    // ✅ Set selected value AFTER loading options
    if (question?.taskType) {
      dropdown.value = question.taskType;
    }
  }).getUniqueTaskTypes();
}


function hideQuestionForm() {
  const form = document.getElementById('questionForm');
  form.reset();
  document.getElementById('questionFormView').classList.add('hidden');

  console.log("🔄 Reloading questions from hideQuestionForm()");
  loadQuestions(); // ✅ ensure this is always run
}

function handleQuestionFormSubmit(e) {
  e.preventDefault();

  const form = document.getElementById('questionForm');
  const id = document.getElementById('questionId')?.value || null;
  const sequenceId = parseInt(document.getElementById('sequenceId').value);
  const requestType = document.getElementById('requestTypeDropdown').value;
  const taskType = document.getElementById('taskTypeDropdown').value;
  const questionText = document.getElementById('questionText').value;
  const pointsPossible = parseFloat(document.getElementById('pointsPossible').value);

  if (!sequenceId || !requestType || !taskType || !questionText || !pointsPossible) {
    showToast("Please fill out all fields correctly.", "warning");
    return;
  }

  const data = { id, sequenceId, requestType, taskType, questionText, pointsPossible };

  console.log("🚀 Submitting question data:", data); // Debug log

  google.script.run
    .withSuccessHandler(() => {
      showToast(`Question ${id ? 'updated' : 'created'} successfully.`, 'success');
      hideQuestionForm();
      loadQuestions(); // ✅ Refresh table
    })
    .withFailureHandler(err => {
      showToast("Error saving question: " + err.message, 'error');
    })
    .saveQuestion(data);
}

function renderQuestionTable(questions) {
  const tbody = document.getElementById('questionListBody');
  if (!tbody) return;

  const taskFilter = document.getElementById('taskTypeFilter').value;
  const requestFilter = document.getElementById('requestTypeFilter').value;

  const filtered = questions.filter(q => {
    const matchTask = !taskFilter || q.taskType === taskFilter;
    const matchRequest = !requestFilter || q.requestType === requestFilter;
    return matchTask && matchRequest;
  });

  tbody.innerHTML = '';

  if (filtered.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No questions available</td></tr>';
    return;
  }

  filtered.forEach(q => {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${q.sequenceId || ''}</td>
      <td>${q.requestType || ''}</td>
      <td>${q.taskType || ''}</td>
      <td>${q.questionText || ''}</td>
      <td>${q.pointsPossible || ''}</td>
      <td>
        <input type="checkbox" class="toggle-active" data-id="${q.id}" ${q.active ? 'checked' : ''}>
      </td>
      <td>
        <button class="btn btn-sm btn-primary" data-id="${q.id}" data-action="edit">Edit</button>
      </td>
    `;
    tbody.appendChild(row);
  });
}

const questionTableBody = document.getElementById('questionListBody');
if (questionTableBody) {
  questionTableBody.addEventListener('click', function (e) {
    const target = e.target;
    const id = target.getAttribute('data-id');

    if (target.classList.contains('toggle-active')) {
      const isActive = target.checked;
      google.script.run.toggleQuestionActive(id, isActive);
    }

    if (target.getAttribute('data-action') === 'edit') {
      google.script.run
        .withSuccessHandler(showQuestionForm)
        .getQuestionById(id);
    }
  });
}


function deleteQuestion(qid) {
  google.script.run
    .withSuccessHandler(() => {
      showToast("Question deleted.", 'success');
      loadQuestions();
    })
    .withFailureHandler(err => showToast("Error deleting question: " + err.message, 'error'))
    .deleteQuestion(qid);
}

  function formatRole(role) {
  if (!role) return 'Unknown';
  return role.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

function formatTaskType(type) {
  if (!type) return 'Unknown';
  return type.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

function escapeHTML(str) {
  if (!str) return '';
  return str.replace(/[&<>"']/g, function (char) {
    return ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    })[char];
  });
}

  function formatDate(dateStr) {
  if (!dateStr) return 'Unknown';
  const date = new Date(dateStr);
  if (isNaN(date.getTime())) return dateStr;

  const cstOffset = -5; // Adjust as needed for DST
  const utc = date.getTime() + (date.getTimezoneOffset() * 60000);
  const cstDate = new Date(utc + (3600000 * cstOffset));

  return cstDate.toLocaleDateString() + ' ' + cstDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

  function createUser(userData) {
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler(resolve)
      .withFailureHandler(reject)
      .createUser(userData);
  });
}

function hideAllViews() {
  // ✅ Automatically reset dispute review status when navigating away
  removeUnloadHandlerForDispute();
  removeUnloadHandlerForDisputeResolution(); // <-- Add this line

  const views = [
    'dashboardView',
    'auditQueueView',
    'evaluationFormView',
    'evaluationsView',
    'disputesView',
    'disputeFormView',
    'adminView',
    'viewEvaluationView',
    'resolveDisputeView'
  ];

  views.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });
}

  // Ensure all navigation and admin event listeners are defined after DOM loads
document.addEventListener('DOMContentLoaded', function () {
  // Fix missing Disputes loader
  if (typeof loadDisputes === 'function') {
    document.getElementById('navDisputes').addEventListener('click', showDisputes);
  }

  // Fix back button on viewEvaluationView
  const closeEvalBtn = document.getElementById('closeViewEvaluation');
  if (closeEvalBtn) {
    closeEvalBtn.addEventListener('click', function () {
      showEvaluations();
    });
  }


  // Ensure admin tab buttons are wired up correctly
  const adminUsersBtn = document.getElementById('adminUsers');
  const adminQuestionsBtn = document.getElementById('adminQuestions');
  const adminSettingsBtn = document.getElementById('adminSettings');

  if (adminUsersBtn) {
    adminUsersBtn.addEventListener('click', () => {
      showAdminTab('adminUsersView');
      loadUsers();
      hideUserForm();
    });
  }

  if (adminQuestionsBtn) {
    adminQuestionsBtn.addEventListener('click', () => {
      showAdminTab('adminQuestionsView');
      loadQuestions();
    });
  }

  if (adminSettingsBtn) {
    adminSettingsBtn.addEventListener('click', () => {
      showAdminTab('adminSettingsView');
    });
  }

  // Ensure Cancel buttons on forms work
  const cancelUserBtn = document.getElementById('cancelUserForm');
  if (cancelUserBtn) {
    cancelUserBtn.addEventListener('click', hideUserForm);
  }

  const cancelQuestionBtn = document.getElementById('cancelQuestionForm');
  if (cancelQuestionBtn) {
    cancelQuestionBtn.addEventListener('click', hideQuestionForm);
  }
});

function clearAuditLockIfExists() {
  if (window.skipUnlock) return; // ✅ prevent reset if marked misconfigured

  const form = document.getElementById('evaluationForm');
  const auditId = form?.getAttribute('data-audit-id');

  if (auditId) {
    google.script.run.fullyUnlockAudit(auditId); // ✅ full unlock
    form.removeAttribute('data-audit-id');
    clearInterval(window.auditHeartbeat);
    window.auditHeartbeat = null;
  }
}

</script>
